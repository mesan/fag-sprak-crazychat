// Package rx implements ReactiveX extensions for Go.
package rx

//go:generate gorx --import=github.com/mesan/fag-sprak-crazychat/crazychat -o rx/rx.go rx crazychat.Message

// NOTE: This file was generated by github.com/alecthomas/gorx/cmd/gorx. Do not modify.

import (
	"errors"
	"sync"
	"sync/atomic"
	"time"

	"github.com/mesan/fag-sprak-crazychat/crazychat"
)

// ErrTimeout is delivered to an observer if the stream times out.
var ErrTimeout = errors.New("timeout")

// MaxReplaySize is the maximum size of a replay buffer. Can be modified.
var MaxReplaySize = 16384

// A Subscription to an observable.
type Subscription interface {
	// Dispose unsubscribes from the subscription.
	Dispose()
	// Disposed returns true if this subscription has been unsubscribed.
	Disposed() bool
}

// SubscriptionEvents provides lifecycle event callbacks for a Subscription.
type SubscriptionEvents interface {
	OnUnsubscribe(func())
}

// A Subscription that is already closed.
type closedSubscription struct{}

func (closedSubscription) Dispose()       {}
func (closedSubscription) Disposed() bool { return true }

// ClosedSubscription always returns true for Disposed()
var ClosedSubscription Subscription = closedSubscription{}

// A LinkedSubscription is a link to a (possible) future Subscription.
type LinkedSubscription struct {
	lock         sync.Mutex
	unsubscribed bool
	linked       Subscription
}

func NewLinkedSubscription() *LinkedSubscription {
	return &LinkedSubscription{}
}

func (l *LinkedSubscription) Link(subscription Subscription) {
	l.lock.Lock()
	defer l.lock.Unlock()
	if l.linked != nil {
		panic("LinkedSubscription is already linked")
	}
	l.linked = subscription
	if l.unsubscribed {
		l.linked.Dispose()
	}
}

func (l *LinkedSubscription) Dispose() {
	l.lock.Lock()
	defer l.lock.Unlock()
	l.unsubscribed = true
	if l.linked != nil {
		l.linked.Dispose()
	}
}

func (l *LinkedSubscription) Disposed() bool {
	l.lock.Lock()
	defer l.lock.Unlock()
	if l.linked != nil {
		return l.linked.Disposed()
	}
	return l.unsubscribed
}

// ChannelSubscription is implemented with a channel which is closed when
// unsubscribed.
type ChannelSubscription chan struct{}

func NewChannelSubscription() ChannelSubscription {
	return make(ChannelSubscription)
}

func (c ChannelSubscription) Dispose() {
	defer recover()
	close(c)
}

func (c ChannelSubscription) Disposed() bool {
	select {
	case _, ok := <-c:
		return !ok
	default:
		return false
	}
}

func (c ChannelSubscription) OnUnsubscribe(handler func()) {
	go func() {
		<-c
		handler()
	}()
}

// GenericSubscription is implemented with atomic operations.
type GenericSubscription int32

func NewGenericSubscription() Subscription {
	return new(GenericSubscription)
}

func (t *GenericSubscription) Dispose() {
	atomic.StoreInt32((*int32)(t), 1)
}

func (t *GenericSubscription) Disposed() bool {
	return atomic.LoadInt32((*int32)(t)) == 1
}

type CallbackSubscription func()

func (c *CallbackSubscription) Dispose() {
	if *c != nil {
		(*c)()
		*c = nil
	}
}

func (c *CallbackSubscription) Disposed() bool {
	return *c == nil
}

// TerminationObserver contains functions for observing termination of a stream.
type TerminationObserver interface {
	Error(error)
	Complete()
}

type GenericObserver interface {
	TerminationObserver
	Next(interface{})
}

type GenericObserverFunc struct {
	f func(interface{}, error, bool)
	Subscription
}

func NewGenericObserverFunc(f func(interface{}, error, bool)) *GenericObserverFunc {
	return &GenericObserverFunc{f, NewGenericSubscription()}
}

func (f *GenericObserverFunc) Next(next interface{}) { f.f(next, nil, false) }
func (f *GenericObserverFunc) Error(err error)       { f.f(nil, err, false) }
func (f *GenericObserverFunc) Complete()             { f.f(nil, nil, true) }

type GenericObservableFilter func(next interface{}, err error, complete bool, observer GenericObserver)

// Turtles all the way down!
type GenericObservableFilterFactory func(GenericObserver) GenericObservableFilter

func ignoreCompletionFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				break
			default:
				observer.Next(next)
			}
		}
	}
}

func distinctFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		seen := map[interface{}]struct{}{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if _, ok := seen[next]; ok {
					return
				}
				seen[next] = struct{}{}
				observer.Next(next)
			}
		}
	}
}

func elementAtFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		i := 0
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if i == n {
					observer.Next(next)
				}
				i++
			}
		}
	}
}

func filterFilter(f func(next interface{}) bool) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if f(next) {
					observer.Next(next)
				}
			}
		}
	}
}

func firstFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		start := true
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if start {
					observer.Next(next)
				}
				start = false
			}
		}
	}
}

func lastFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		have := false
		var last interface{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				if have {
					observer.Next(last)
				}
				observer.Error(err)
			case complete:
				if have {
					observer.Next(last)
				}
				observer.Complete()
			default:
				last = next
				have = true
			}
		}
	}
}

func takeLastFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		read := 0
		write := 0
		n++
		buffer := make([]interface{}, n)
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				for read != write {
					observer.Next(buffer[read])
					read = (read + 1) % n
				}
				observer.Error(err)
			case complete:
				for read != write {
					observer.Next(buffer[read])
					read = (read + 1) % n
				}
				observer.Complete()
			default:
				buffer[write] = next
				write = (write + 1) % n
				if write == read {
					read = (read + 1) % n
				}
			}
		}
	}
}

func takeFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		taken := 0
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			if taken >= n {
				return
			}
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				observer.Next(next)
				taken++
				if taken >= n {
					observer.Complete()
				}
			}
		}
	}
}

func ignoreElementsFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			}
		}
	}
}

func skipFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		i := 0
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if i >= n {
					observer.Next(next)
				}
				i++
			}
		}
	}
}

func skipLastFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		read := 0
		write := 0
		n++
		buffer := make([]interface{}, n)
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				buffer[write] = next
				write = (write + 1) % n
				if write == read {
					observer.Next(buffer[read])
					read = (read + 1) % n
				}
			}
		}
	}
}

func oneFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		count := 0
		var value interface{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			if count > 1 {
				return
			}
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				if count == 2 {
					observer.Error(errors.New("expected one value"))
				} else {
					observer.Next(value)
					observer.Complete()
				}
			default:
				count++
				if count == 2 {
					observer.Error(errors.New("expected one value"))
					return
				}
				value = next
			}
		}
	}
}

func sampleFilter(window time.Duration) GenericObservableFilterFactory {
	return func(observer GenericObserver) GenericObservableFilter {
		mutex := &sync.Mutex{}
		cancel := make(chan bool, 1)
		var last interface{}
		haveNew := false
		go func() {
			for {
				select {
				case <-time.After(window):
					mutex.Lock()
					if haveNew {
						observer.Next(last)
						haveNew = false
					}
					mutex.Unlock()
				case <-cancel:
					return
				}
			}
		}()
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				cancel <- true
				observer.Error(err)
			case complete:
				cancel <- true
				observer.Complete()
			default:
				mutex.Lock()
				last = next
				haveNew = true
				mutex.Unlock()
			}
		}
	}
}

func debounceFilter(duration time.Duration) GenericObservableFilterFactory {
	return func(observer GenericObserver) GenericObservableFilter {
		errch := make(chan error)
		completech := make(chan bool)
		valuech := make(chan interface{})
		go func() {
			var timeout <-chan time.Time
			var nextValue interface{}
			for {
				select {
				case <-timeout:
					observer.Next(nextValue)
					timeout = nil
				case nextValue = <-valuech:
					timeout = time.After(duration)
				case err := <-errch:
					if timeout != nil {
						observer.Next(nextValue)
					}
					observer.Error(err)
					return
				case <-completech:
					if timeout != nil {
						observer.Next(nextValue)
					}
					observer.Complete()
					return
				}
			}
		}()
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				errch <- err
			case complete:
				completech <- true
			default:
				valuech <- next
			}
		}
	}
}

type timedEntry struct {
	v interface{}
	t time.Time
}

func replayFilter(size int, duration time.Duration) GenericObservableFilterFactory {
	read := 0
	write := 0
	if size == 0 {
		size = MaxReplaySize
	}
	if duration == 0 {
		duration = time.Hour * 24 * 7 * 52
	}
	size++
	buffer := make([]timedEntry, size)
	return func(observer GenericObserver) GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			now := time.Now()
			switch {
			case err != nil:
				cursor := read
				for cursor != write {
					if buffer[cursor].t.After(now) {
						observer.Next(buffer[cursor].v)
					}
					cursor = (cursor + 1) % size
				}
				observer.Error(err)
			case complete:
				cursor := read
				for cursor != write {
					if buffer[cursor].t.After(now) {
						observer.Next(buffer[cursor].v)
					}
					cursor = (cursor + 1) % size
				}
				observer.Complete()
			default:
				buffer[write] = timedEntry{next, time.Now().Add(duration)}
				write = (write + 1) % size
				if write == read {
					if buffer[read].t.After(now) {
						observer.Next(buffer[read].v)
					}
					read = (read + 1) % size
				}
			}
		}
	}
}

func Range(start, count int) *IntStream {
	end := start + count
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		for i := start; i < end; i++ {
			if subscription.Disposed() {
				return
			}
			observer.Next(i)
		}
		observer.Complete()
		subscription.Dispose()
	})
}

func Interval(interval time.Duration) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		i := 0
		for {
			time.Sleep(interval)
			if subscription.Disposed() {
				return
			}
			observer.Next(i)
			i++
		}
	})
}

type MessageObserver interface {
	Next(crazychat.Message)
	TerminationObserver
}

// A MessageSubscriber represents a subscribed MessageObserver.
type MessageSubscriber interface {
	Subscription
	MessageObserver
}

type implMessageSubscriber struct {
	Subscription
	MessageObserver
}

func MessageObserverAsGenericObserver(observer MessageObserver) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(crazychat.Message))
		}
	})
}

func GenericObserverAsMessageObserver(observer GenericObserver) MessageObserver {
	return MessageObserverFunc(func(next crazychat.Message, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type MessageObservableFactory func(observer MessageObserver, subscription Subscription)

func (f MessageObservableFactory) Subscribe(observer MessageObserver) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateMessage calls f(observer, subscription) to produce values for a stream.
func CreateMessage(f func(observer MessageObserver, subscription Subscription)) *MessageStream {
	return FromMessageObservable(MessageObservableFactory(f))
}

// Repeat value count times.
func RepeatMessage(value crazychat.Message, count int) *MessageStream {
	return CreateMessage(func(observer MessageObserver, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Disposed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartMessage is designed to be used with functions that return a
// (crazychat.Message, error) tuple.
//
// If the error is non-nil the returned MessageStream will be that error,
// otherwise it will be a single-value stream of crazychat.Message.
func StartMessage(f func() (crazychat.Message, error)) *MessageStream {
	return CreateMessage(func(observer MessageObserver, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughMessage(next crazychat.Message, err error, complete bool, observer MessageObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroMessage = *new(crazychat.Message)

type MessageObserverFunc func(crazychat.Message, error, bool)

func (f MessageObserverFunc) Next(next crazychat.Message) { f(next, nil, false) }
func (f MessageObserverFunc) Error(err error)             { f(zeroMessage, err, false) }
func (f MessageObserverFunc) Complete()                   { f(zeroMessage, nil, true) }

type MessageObservable interface {
	Subscribe(MessageObserver) Subscription
}

// Convert a GenericObservableFilter to a MessageObservable
func (f GenericObservableFilterFactory) Message(parent MessageObservable) MessageObservable {
	return MapMessage2MessageObservable(parent, func(observer MessageObserver) MappingMessage2MessageFunc {
		gobserver := MessageObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next crazychat.Message, err error, complete bool, observer MessageObserver) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverMessage() *MessageStream {
	return CreateMessage(func(observer MessageObserver, subscription Subscription) {})
}

func EmptyMessage() *MessageStream {
	return CreateMessage(func(observer MessageObserver, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowMessage(err error) *MessageStream {
	return CreateMessage(func(observer MessageObserver, subscription Subscription) {
		observer.Error(err)
	})
}

func FromMessageArray(array []crazychat.Message) *MessageStream {
	return CreateMessage(func(observer MessageObserver, subscription Subscription) {
		for _, v := range array {
			if subscription.Disposed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Dispose()
	})
}

func FromMessages(array ...crazychat.Message) *MessageStream {
	return FromMessageArray(array)
}

func JustMessage(element crazychat.Message) *MessageStream {
	return FromMessageArray([]crazychat.Message{element})
}

func MergeMessage(observables ...MessageObservable) *MessageStream {
	if len(observables) == 0 {
		return EmptyMessage()
	}
	return (&MessageStream{observables[0]}).Merge(observables[1:]...)
}

func MergeMessageDelayError(observables ...MessageObservable) *MessageStream {
	if len(observables) == 0 {
		return EmptyMessage()
	}
	return (&MessageStream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromMessageChannel(ch <-chan crazychat.Message) *MessageStream {
	return CreateMessage(func(observer MessageObserver, subscription Subscription) {
		for v := range ch {
			if subscription.Disposed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type MessageStream struct {
	MessageObservable
}

func FromMessageObservable(observable MessageObservable) *MessageStream {
	return &MessageStream{observable}
}

func (s *MessageStream) SubscribeFunc(f func(crazychat.Message, error, bool)) Subscription {
	return s.Subscribe(MessageObserverFunc(f))
}

func (s *MessageStream) SubscribeNext(f func(v crazychat.Message)) Subscription {
	return s.SubscribeFunc(func(next crazychat.Message, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *MessageStream) Distinct() *MessageStream {
	return FromMessageObservable(distinctFilter().Message(s))
}

// ElementAt yields the Nth element of the stream.
func (s *MessageStream) ElementAt(n int) *MessageStream {
	return FromMessageObservable(elementAtFilter(n).Message(s))
}

// Filter elements in the stream on a function.
func (s *MessageStream) Filter(f func(crazychat.Message) bool) *MessageStream {
	return FromMessageObservable(filterFilter(func(v interface{}) bool { return f(v.(crazychat.Message)) }).Message(s))
}

// Last returns just the first element of the stream.
func (s *MessageStream) First() *MessageStream {
	return FromMessageObservable(firstFilter().Message(s))
}

// Last returns just the last element of the stream.
func (s *MessageStream) Last() *MessageStream {
	return FromMessageObservable(lastFilter().Message(s))
}

// SkipLast skips the first N elements of the stream.
func (s *MessageStream) Skip(n int) *MessageStream {
	return FromMessageObservable(skipFilter(n).Message(s))
}

// SkipLast skips the last N elements of the stream.
func (s *MessageStream) SkipLast(n int) *MessageStream {
	return FromMessageObservable(skipLastFilter(n).Message(s))
}

// Take returns just the first N elements of the stream.
func (s *MessageStream) Take(n int) *MessageStream {
	return FromMessageObservable(takeFilter(n).Message(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *MessageStream) TakeLast(n int) *MessageStream {
	return FromMessageObservable(takeLastFilter(n).Message(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *MessageStream) IgnoreElements() *MessageStream {
	return FromMessageObservable(ignoreElementsFilter().Message(s))
}

func (s *MessageStream) Replay(size int, duration time.Duration) *MessageStream {
	return FromMessageObservable(replayFilter(size, duration).Message(s))
}

func (s *MessageStream) Sample(duration time.Duration) *MessageStream {
	return FromMessageObservable(sampleFilter(duration).Message(s))
}

func (s *MessageStream) Debounce(duration time.Duration) *MessageStream {
	return FromMessageObservable(debounceFilter(duration).Message(s))
}

// Wait for completion of the stream and return any error.
func (s *MessageStream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next crazychat.Message, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeMessageSubscriber(observer MessageObserver) MessageSubscriber {
	if subscriber, ok := observer.(MessageSubscriber); ok {
		return subscriber
	}
	return &implMessageSubscriber{NewGenericSubscription(), observer}
}

type concatMessageSubscriber struct {
	observable  int
	observer    MessageObserver
	observables []MessageObservable
	Subscription
}

func (c *concatMessageSubscriber) Next(next crazychat.Message) {
	c.observer.Next(next)
}

func (c *concatMessageSubscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Dispose()
}

func (c *concatMessageSubscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Dispose()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatMessageObservable struct {
	observables []MessageObservable
}

func (m *concatMessageObservable) Subscribe(observer MessageObserver) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatMessageSubscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *MessageStream) Concat(observables ...MessageObservable) *MessageStream {
	return &MessageStream{&concatMessageObservable{append([]MessageObservable{s}, observables...)}}
}

type mergeMessageObservable struct {
	delayError  bool
	observables []MessageObservable
}

func (m *mergeMessageObservable) Subscribe(observer MessageObserver) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next crazychat.Message, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(MessageObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *MessageStream) Merge(other ...MessageObservable) *MessageStream {
	if len(other) == 0 {
		return s
	}
	return &MessageStream{&mergeMessageObservable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *MessageStream) MergeDelayError(other ...MessageObservable) *MessageStream {
	if len(other) == 0 {
		return s
	}
	return &MessageStream{&mergeMessageObservable{true, append(other, s)}}
}

type catchMessageObservable struct {
	parent MessageObservable
	catch  MessageObservable
}

func (r *catchMessageObservable) Subscribe(observer MessageObserver) Subscription {
	subscription := NewGenericSubscription()
	run := func(next crazychat.Message, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(MessageObserverFunc(run))
	return subscription
}

func (s *MessageStream) Catch(catch MessageObservable) *MessageStream {
	return &MessageStream{&catchMessageObservable{s, catch}}
}

type retryMessageObservable struct {
	observable MessageObservable
}

type retryMessageObserver struct {
	observable MessageObservable
	observer   MessageObserver
}

func (r *retryMessageObserver) retry(next crazychat.Message, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(MessageObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryMessageObservable) Subscribe(observer MessageObserver) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryMessageObserver{r.observable, observer}
	r.observable.Subscribe(MessageObserverFunc(ro.retry))
	return subscription
}

func (s *MessageStream) Retry() *MessageStream {
	return &MessageStream{&retryMessageObservable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *MessageStream) Do(f func(next crazychat.Message)) *MessageStream {
	return FromMessageObservable(MapMessage2MessageObserveNext(s, func(next crazychat.Message) crazychat.Message {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *MessageStream) DoOnError(f func(err error)) *MessageStream {
	return FromMessageObservable(MapMessage2MessageObserveDirect(s, func(next crazychat.Message, err error, complete bool, observer MessageObserver) {
		if err != nil {
			f(err)
		}
		PassthroughMessage(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *MessageStream) DoOnComplete(f func()) *MessageStream {
	return FromMessageObservable(MapMessage2MessageObserveDirect(s, func(next crazychat.Message, err error, complete bool, observer MessageObserver) {
		if complete {
			f()
		}
		PassthroughMessage(next, err, complete, observer)
	}))
}

func (s *MessageStream) Reduce(initial crazychat.Message, reducer func(crazychat.Message, crazychat.Message) crazychat.Message) *MessageStream {
	value := initial
	return FromMessageObservable(MapMessage2MessageObserveDirect(s, func(next crazychat.Message, err error, complete bool, observer MessageObserver) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *MessageStream) Scan(initial crazychat.Message, f func(crazychat.Message, crazychat.Message) crazychat.Message) *MessageStream {
	value := initial
	return FromMessageObservable(MapMessage2MessageObserveDirect(s, func(next crazychat.Message, err error, complete bool, observer MessageObserver) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutMessage struct {
	parent  MessageObservable
	timeout time.Duration
}

func (t *timeoutMessage) Subscribe(observer MessageObserver) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			cancel.Dispose()
			subscription.Dispose()
		case <-subscription:
			cancel.Dispose()
		}
	}()
	return subscription
}

func (s *MessageStream) Timeout(timeout time.Duration) *MessageStream {
	return &MessageStream{&timeoutMessage{s, timeout}}
}

type forkedMessageStream struct {
	lock      sync.Mutex
	parent    MessageObservable
	observers []MessageObserver
}

func (f *forkedMessageStream) Subscribe(observer MessageObserver) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	i := len(f.observers)
	f.observers = append(f.observers, observer)
	sub := new(CallbackSubscription)
	*sub = CallbackSubscription(func() {
		f.lock.Lock()
		defer f.lock.Unlock()
		f.observers[i] = nil
	})
	return sub
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *MessageStream) Fork() *MessageStream {
	f := &forkedMessageStream{parent: s}
	go s.Subscribe(MessageObserverFunc(func(n crazychat.Message, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			if o == nil {
				continue
			}
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &MessageStream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *MessageStream) ToOneWithError() (crazychat.Message, error) {
	valuech := make(chan crazychat.Message, 1)
	errch := make(chan error, 1)
	FromMessageObservable(oneFilter().Message(s)).SubscribeFunc(func(next crazychat.Message, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroMessage, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *MessageStream) ToOne() crazychat.Message {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *MessageStream) ToArrayWithError() ([]crazychat.Message, error) {
	array := []crazychat.Message{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next crazychat.Message, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *MessageStream) ToArray() []crazychat.Message {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *MessageStream) ToChannelWithError() (<-chan crazychat.Message, <-chan error) {
	ch := make(chan crazychat.Message, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next crazychat.Message, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *MessageStream) ToChannel() <-chan crazychat.Message {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *MessageStream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapMessage2IntObserveDirect(s, func(next crazychat.Message, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

type MappingMessage2MessageFunc func(next crazychat.Message, err error, complete bool, observer MessageObserver)
type MappingMessage2MessageFuncFactory func(observer MessageObserver) MappingMessage2MessageFunc

type MappingMessage2MessageObservable struct {
	parent MessageObservable
	mapper MappingMessage2MessageFuncFactory
}

func (f *MappingMessage2MessageObservable) Subscribe(observer MessageObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(MessageObserverFunc(func(next crazychat.Message, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapMessage2MessageObservable(parent MessageObservable, mapper MappingMessage2MessageFuncFactory) MessageObservable {
	return &MappingMessage2MessageObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapMessage2MessageObserveDirect(parent MessageObservable, mapper MappingMessage2MessageFunc) MessageObservable {
	return MapMessage2MessageObservable(parent, func(MessageObserver) MappingMessage2MessageFunc {
		return mapper
	})
}

func MapMessage2MessageObserveNext(parent MessageObservable, mapper func(crazychat.Message) crazychat.Message) MessageObservable {
	return MapMessage2MessageObservable(parent, func(MessageObserver) MappingMessage2MessageFunc {
		return func(next crazychat.Message, err error, complete bool, observer MessageObserver) {
			var mapped crazychat.Message
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughMessage(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapMessage2Message struct {
	parent MessageObservable
	mapper func(crazychat.Message) MessageObservable
}

func (f *flatMapMessage2Message) Subscribe(observer MessageObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(MessageObserverFunc(func(next crazychat.Message, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&MessageStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &MessageStream{ignoreCompletionFilter().Message(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *MessageStream) Map(f func(crazychat.Message) crazychat.Message) *MessageStream {
	return FromMessageObservable(MapMessage2MessageObserveNext(s, f))
}

func (s *MessageStream) FlatMap(f func(crazychat.Message) MessageObservable) *MessageStream {
	return &MessageStream{&flatMapMessage2Message{s, f}}
}

type MappingMessage2IntFunc func(next crazychat.Message, err error, complete bool, observer IntObserver)
type MappingMessage2IntFuncFactory func(observer IntObserver) MappingMessage2IntFunc

type MappingMessage2IntObservable struct {
	parent MessageObservable
	mapper MappingMessage2IntFuncFactory
}

func (f *MappingMessage2IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(MessageObserverFunc(func(next crazychat.Message, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapMessage2IntObservable(parent MessageObservable, mapper MappingMessage2IntFuncFactory) IntObservable {
	return &MappingMessage2IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapMessage2IntObserveDirect(parent MessageObservable, mapper MappingMessage2IntFunc) IntObservable {
	return MapMessage2IntObservable(parent, func(IntObserver) MappingMessage2IntFunc {
		return mapper
	})
}

func MapMessage2IntObserveNext(parent MessageObservable, mapper func(crazychat.Message) int) IntObservable {
	return MapMessage2IntObservable(parent, func(IntObserver) MappingMessage2IntFunc {
		return func(next crazychat.Message, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapMessage2Int struct {
	parent MessageObservable
	mapper func(crazychat.Message) IntObservable
}

func (f *flatMapMessage2Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(MessageObserverFunc(func(next crazychat.Message, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *MessageStream) MapInt(f func(crazychat.Message) int) *IntStream {
	return FromIntObservable(MapMessage2IntObserveNext(s, f))
}

func (s *MessageStream) FlatMapInt(f func(crazychat.Message) IntObservable) *IntStream {
	return &IntStream{&flatMapMessage2Int{s, f}}
}

type IntObserver interface {
	Next(int)
	TerminationObserver
}

// A IntSubscriber represents a subscribed IntObserver.
type IntSubscriber interface {
	Subscription
	IntObserver
}

type implIntSubscriber struct {
	Subscription
	IntObserver
}

func IntObserverAsGenericObserver(observer IntObserver) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(int))
		}
	})
}

func GenericObserverAsIntObserver(observer GenericObserver) IntObserver {
	return IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type IntObservableFactory func(observer IntObserver, subscription Subscription)

func (f IntObservableFactory) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateInt calls f(observer, subscription) to produce values for a stream.
func CreateInt(f func(observer IntObserver, subscription Subscription)) *IntStream {
	return FromIntObservable(IntObservableFactory(f))
}

// Repeat value count times.
func RepeatInt(value int, count int) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Disposed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartInt is designed to be used with functions that return a
// (int, error) tuple.
//
// If the error is non-nil the returned IntStream will be that error,
// otherwise it will be a single-value stream of int.
func StartInt(f func() (int, error)) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughInt(next int, err error, complete bool, observer IntObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroInt = *new(int)

type IntObserverFunc func(int, error, bool)

func (f IntObserverFunc) Next(next int)   { f(next, nil, false) }
func (f IntObserverFunc) Error(err error) { f(zeroInt, err, false) }
func (f IntObserverFunc) Complete()       { f(zeroInt, nil, true) }

type IntObservable interface {
	Subscribe(IntObserver) Subscription
}

// Convert a GenericObservableFilter to a IntObservable
func (f GenericObservableFilterFactory) Int(parent IntObservable) IntObservable {
	return MapInt2IntObservable(parent, func(observer IntObserver) MappingInt2IntFunc {
		gobserver := IntObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next int, err error, complete bool, observer IntObserver) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverInt() *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {})
}

func EmptyInt() *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowInt(err error) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		observer.Error(err)
	})
}

func FromIntArray(array []int) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		for _, v := range array {
			if subscription.Disposed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Dispose()
	})
}

func FromInts(array ...int) *IntStream {
	return FromIntArray(array)
}

func JustInt(element int) *IntStream {
	return FromIntArray([]int{element})
}

func MergeInt(observables ...IntObservable) *IntStream {
	if len(observables) == 0 {
		return EmptyInt()
	}
	return (&IntStream{observables[0]}).Merge(observables[1:]...)
}

func MergeIntDelayError(observables ...IntObservable) *IntStream {
	if len(observables) == 0 {
		return EmptyInt()
	}
	return (&IntStream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromIntChannel(ch <-chan int) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		for v := range ch {
			if subscription.Disposed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type IntStream struct {
	IntObservable
}

func FromIntObservable(observable IntObservable) *IntStream {
	return &IntStream{observable}
}

func (s *IntStream) SubscribeFunc(f func(int, error, bool)) Subscription {
	return s.Subscribe(IntObserverFunc(f))
}

func (s *IntStream) SubscribeNext(f func(v int)) Subscription {
	return s.SubscribeFunc(func(next int, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *IntStream) Distinct() *IntStream {
	return FromIntObservable(distinctFilter().Int(s))
}

// ElementAt yields the Nth element of the stream.
func (s *IntStream) ElementAt(n int) *IntStream {
	return FromIntObservable(elementAtFilter(n).Int(s))
}

// Filter elements in the stream on a function.
func (s *IntStream) Filter(f func(int) bool) *IntStream {
	return FromIntObservable(filterFilter(func(v interface{}) bool { return f(v.(int)) }).Int(s))
}

// Last returns just the first element of the stream.
func (s *IntStream) First() *IntStream {
	return FromIntObservable(firstFilter().Int(s))
}

// Last returns just the last element of the stream.
func (s *IntStream) Last() *IntStream {
	return FromIntObservable(lastFilter().Int(s))
}

// SkipLast skips the first N elements of the stream.
func (s *IntStream) Skip(n int) *IntStream {
	return FromIntObservable(skipFilter(n).Int(s))
}

// SkipLast skips the last N elements of the stream.
func (s *IntStream) SkipLast(n int) *IntStream {
	return FromIntObservable(skipLastFilter(n).Int(s))
}

// Take returns just the first N elements of the stream.
func (s *IntStream) Take(n int) *IntStream {
	return FromIntObservable(takeFilter(n).Int(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *IntStream) TakeLast(n int) *IntStream {
	return FromIntObservable(takeLastFilter(n).Int(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *IntStream) IgnoreElements() *IntStream {
	return FromIntObservable(ignoreElementsFilter().Int(s))
}

func (s *IntStream) Replay(size int, duration time.Duration) *IntStream {
	return FromIntObservable(replayFilter(size, duration).Int(s))
}

func (s *IntStream) Sample(duration time.Duration) *IntStream {
	return FromIntObservable(sampleFilter(duration).Int(s))
}

func (s *IntStream) Debounce(duration time.Duration) *IntStream {
	return FromIntObservable(debounceFilter(duration).Int(s))
}

// Wait for completion of the stream and return any error.
func (s *IntStream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeIntSubscriber(observer IntObserver) IntSubscriber {
	if subscriber, ok := observer.(IntSubscriber); ok {
		return subscriber
	}
	return &implIntSubscriber{NewGenericSubscription(), observer}
}

type concatIntSubscriber struct {
	observable  int
	observer    IntObserver
	observables []IntObservable
	Subscription
}

func (c *concatIntSubscriber) Next(next int) {
	c.observer.Next(next)
}

func (c *concatIntSubscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Dispose()
}

func (c *concatIntSubscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Dispose()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatIntObservable struct {
	observables []IntObservable
}

func (m *concatIntObservable) Subscribe(observer IntObserver) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatIntSubscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *IntStream) Concat(observables ...IntObservable) *IntStream {
	return &IntStream{&concatIntObservable{append([]IntObservable{s}, observables...)}}
}

type mergeIntObservable struct {
	delayError  bool
	observables []IntObservable
}

func (m *mergeIntObservable) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next int, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(IntObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *IntStream) Merge(other ...IntObservable) *IntStream {
	if len(other) == 0 {
		return s
	}
	return &IntStream{&mergeIntObservable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *IntStream) MergeDelayError(other ...IntObservable) *IntStream {
	if len(other) == 0 {
		return s
	}
	return &IntStream{&mergeIntObservable{true, append(other, s)}}
}

type catchIntObservable struct {
	parent IntObservable
	catch  IntObservable
}

func (r *catchIntObservable) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	run := func(next int, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(IntObserverFunc(run))
	return subscription
}

func (s *IntStream) Catch(catch IntObservable) *IntStream {
	return &IntStream{&catchIntObservable{s, catch}}
}

type retryIntObservable struct {
	observable IntObservable
}

type retryIntObserver struct {
	observable IntObservable
	observer   IntObserver
}

func (r *retryIntObserver) retry(next int, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(IntObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryIntObservable) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryIntObserver{r.observable, observer}
	r.observable.Subscribe(IntObserverFunc(ro.retry))
	return subscription
}

func (s *IntStream) Retry() *IntStream {
	return &IntStream{&retryIntObservable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *IntStream) Do(f func(next int)) *IntStream {
	return FromIntObservable(MapInt2IntObserveNext(s, func(next int) int {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *IntStream) DoOnError(f func(err error)) *IntStream {
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		if err != nil {
			f(err)
		}
		PassthroughInt(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *IntStream) DoOnComplete(f func()) *IntStream {
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		if complete {
			f()
		}
		PassthroughInt(next, err, complete, observer)
	}))
}

func (s *IntStream) Reduce(initial int, reducer func(int, int) int) *IntStream {
	value := initial
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *IntStream) Scan(initial int, f func(int, int) int) *IntStream {
	value := initial
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutInt struct {
	parent  IntObservable
	timeout time.Duration
}

func (t *timeoutInt) Subscribe(observer IntObserver) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			cancel.Dispose()
			subscription.Dispose()
		case <-subscription:
			cancel.Dispose()
		}
	}()
	return subscription
}

func (s *IntStream) Timeout(timeout time.Duration) *IntStream {
	return &IntStream{&timeoutInt{s, timeout}}
}

type forkedIntStream struct {
	lock      sync.Mutex
	parent    IntObservable
	observers []IntObserver
}

func (f *forkedIntStream) Subscribe(observer IntObserver) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	i := len(f.observers)
	f.observers = append(f.observers, observer)
	sub := new(CallbackSubscription)
	*sub = CallbackSubscription(func() {
		f.lock.Lock()
		defer f.lock.Unlock()
		f.observers[i] = nil
	})
	return sub
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *IntStream) Fork() *IntStream {
	f := &forkedIntStream{parent: s}
	go s.Subscribe(IntObserverFunc(func(n int, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			if o == nil {
				continue
			}
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &IntStream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *IntStream) ToOneWithError() (int, error) {
	valuech := make(chan int, 1)
	errch := make(chan error, 1)
	FromIntObservable(oneFilter().Int(s)).SubscribeFunc(func(next int, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroInt, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *IntStream) ToOne() int {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *IntStream) ToArrayWithError() ([]int, error) {
	array := []int{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *IntStream) ToArray() []int {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *IntStream) ToChannelWithError() (<-chan int, <-chan error) {
	ch := make(chan int, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *IntStream) ToChannel() <-chan int {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *IntStream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *IntStream) Average() *IntStream {
	var sum int
	var count int
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *IntStream) Sum() *IntStream {
	var sum int
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *IntStream) Min() *IntStream {
	started := false
	var min int
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *IntStream) Max() *IntStream {
	started := false
	var max int
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingInt2MessageFunc func(next int, err error, complete bool, observer MessageObserver)
type MappingInt2MessageFuncFactory func(observer MessageObserver) MappingInt2MessageFunc

type MappingInt2MessageObservable struct {
	parent IntObservable
	mapper MappingInt2MessageFuncFactory
}

func (f *MappingInt2MessageObservable) Subscribe(observer MessageObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2MessageObservable(parent IntObservable, mapper MappingInt2MessageFuncFactory) MessageObservable {
	return &MappingInt2MessageObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2MessageObserveDirect(parent IntObservable, mapper MappingInt2MessageFunc) MessageObservable {
	return MapInt2MessageObservable(parent, func(MessageObserver) MappingInt2MessageFunc {
		return mapper
	})
}

func MapInt2MessageObserveNext(parent IntObservable, mapper func(int) crazychat.Message) MessageObservable {
	return MapInt2MessageObservable(parent, func(MessageObserver) MappingInt2MessageFunc {
		return func(next int, err error, complete bool, observer MessageObserver) {
			var mapped crazychat.Message
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughMessage(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Message struct {
	parent IntObservable
	mapper func(int) MessageObservable
}

func (f *flatMapInt2Message) Subscribe(observer MessageObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&MessageStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &MessageStream{ignoreCompletionFilter().Message(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapMessage maps this stream to an MessageStream via f.
func (s *IntStream) MapMessage(f func(int) crazychat.Message) *MessageStream {
	return FromMessageObservable(MapInt2MessageObserveNext(s, f))
}

func (s *IntStream) FlatMapMessage(f func(int) MessageObservable) *MessageStream {
	return &MessageStream{&flatMapInt2Message{s, f}}
}

type MappingInt2IntFunc func(next int, err error, complete bool, observer IntObserver)
type MappingInt2IntFuncFactory func(observer IntObserver) MappingInt2IntFunc

type MappingInt2IntObservable struct {
	parent IntObservable
	mapper MappingInt2IntFuncFactory
}

func (f *MappingInt2IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2IntObservable(parent IntObservable, mapper MappingInt2IntFuncFactory) IntObservable {
	return &MappingInt2IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2IntObserveDirect(parent IntObservable, mapper MappingInt2IntFunc) IntObservable {
	return MapInt2IntObservable(parent, func(IntObserver) MappingInt2IntFunc {
		return mapper
	})
}

func MapInt2IntObserveNext(parent IntObservable, mapper func(int) int) IntObservable {
	return MapInt2IntObservable(parent, func(IntObserver) MappingInt2IntFunc {
		return func(next int, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Int struct {
	parent IntObservable
	mapper func(int) IntObservable
}

func (f *flatMapInt2Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *IntStream) Map(f func(int) int) *IntStream {
	return FromIntObservable(MapInt2IntObserveNext(s, f))
}

func (s *IntStream) FlatMap(f func(int) IntObservable) *IntStream {
	return &IntStream{&flatMapInt2Int{s, f}}
}
